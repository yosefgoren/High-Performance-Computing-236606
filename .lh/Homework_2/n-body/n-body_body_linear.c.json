{
    "sourceFile": "Homework_2/n-body/n-body_body_linear.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1673101796675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1673101812653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,12 +82,12 @@\n         force[0] += delta[0] * invDist3;\n         force[1] += delta[1] * invDist3;\n         force[2] += delta[2] * invDist3;\n       }\n-      float* vs = p->velocities[effected];\n-      vs[0] += dt*force[0];\n-      vs[1] += dt*force[1];\n-      vs[2] += dt*force[2];\n+      float* vs = ;\n+      p->velocities[0][effected] += dt*force[0];\n+      p->velocities[1][effected] += dt*force[1];\n+      p->velocities[2][effected] += dt*force[2];\n     }\n     #pragma omp parallel for schedule(guided)\n     for(int effected = 0; effected < N_BODIES; ++effected){\n       float* pos = p->positions[effected];\n"
                },
                {
                    "date": 1673101836838,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,20 +82,17 @@\n         force[0] += delta[0] * invDist3;\n         force[1] += delta[1] * invDist3;\n         force[2] += delta[2] * invDist3;\n       }\n-      float* vs = ;\n       p->velocities[0][effected] += dt*force[0];\n       p->velocities[1][effected] += dt*force[1];\n       p->velocities[2][effected] += dt*force[2];\n     }\n     #pragma omp parallel for schedule(guided)\n     for(int effected = 0; effected < N_BODIES; ++effected){\n-      float* pos = p->positions[effected];\n-      float* vel = p->velocities[effected];\n-      pos[0] += vel[0] * dt;\n-      pos[1] += vel[1] * dt;\n-      pos[2] += vel[2] * dt;\n+      p->positions[0][effected] += p->velocities[0][effected] * dt;\n+      p->positions[1][effected] += p->velocities[1][effected] * dt;\n+      p->positions[2][effected] += p->velocities[2][effected] * dt;\n     }\n   }\n   printf(\"Parallel Execution time: %f seconds with %d threads\\n\\n\", omp_get_wtime()-start_time, NUM_THREADS);\n \n"
                },
                {
                    "date": 1673101914714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,9 +97,9 @@\n   printf(\"Parallel Execution time: %f seconds with %d threads\\n\\n\", omp_get_wtime()-start_time, NUM_THREADS);\n \n   float res[3];\n   for(int dim = 0; dim < N_DIMS; ++dim){\n-    res[dim] = p->positions[0][dim];\n+    res[dim] = p->positions[dim][0];\n   }\n   free(p);\n \n   const float ref[3] = {102.497765, 107.869682, -2.093829};\n"
                }
            ],
            "date": 1673101796675,
            "name": "Commit-0",
            "content": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#define NUM_THREADS 16\n#define SOFTENING 1e-9f\n\n#define N_BODIES 20000\n#define N_DIMS 3\n\ntypedef struct { float x, y, z, vx, vy, vz; } Body;\n\ntypedef struct { float positions[N_DIMS][N_BODIES], velocities[N_DIMS][N_BODIES]; } Bodies;\n\nvoid randomizeBodies_old(float *data, int n) {\n  for (int i = 0; i < n; i++) {\n    data[i] = 2.0f * (rand() / (float)RAND_MAX) - 1.0f;\n  }\n}\n\nvoid randomizeBodies(Bodies* data) {\n  int bytes = N_BODIES*sizeof(Body);\n  float *buf = (float*)malloc(bytes);\n  Body *p = (Body*)buf;\n  randomizeBodies_old(buf, 6*N_BODIES);\n  for(int i = 0; i < N_BODIES; ++i){\n    data->positions[0][i] = p[i].x;\n    data->positions[1][i] = p[i].y;\n    data->positions[2][i] = p[i].z;\n    data->velocities[0][i] = p[i].vx;\n    data->velocities[1][i] = p[i].vy;\n    data->velocities[2][i] = p[i].vz;\n  }\n  free(buf);\n}\n\nvoid update_loading_icon(char* c, int iter){\n  switch(iter%8){\n    case 0: *c = '-'; break;\n    case 1: *c = '\\\\'; break;\n    case 2: *c = '|'; break;\n    case 3: *c = '/'; break;\n    case 4: *c = '-'; break;\n    case 5: *c = '\\\\'; break;\n    case 6: *c = '|'; break;\n    case 7: *c = '/'; break;\n  }\n}\n\n\nint main(const int argc, const char** argv) {\n  \n  srand(42);//make deterministic.\n\n  const float dt = 0.01f; // time step\n  const int nIters = 10;  // simulation iterations\n  \n  omp_set_num_threads(NUM_THREADS);\n  Bodies *p = (Bodies*)malloc(sizeof(Bodies));\n\n  randomizeBodies(p);\n  \n  double totalTime = 0.0;\n  double start_time = omp_get_wtime();\n  for (int iter = 1; iter <= nIters; iter++) {\n    char c;\n    // update_loading_icon(&c, iter);\n    // printf(\"%c Crunching Numbers...\\r\", c);\n\n    #pragma omp parallel for schedule(guided)\n    for(int effected = 0; effected < N_BODIES; ++effected){\n      float force[N_DIMS] = {0.0f, 0.0f, 0.0f};\n      \n      for(int j = 0; j < N_BODIES; ++j){\n        float delta[N_DIMS];\n        delta[0] = p->positions[0][j] - p->positions[0][effected];\n        delta[1] = p->positions[1][j] - p->positions[1][effected];\n        delta[2] = p->positions[2][j] - p->positions[2][effected];\n        float distSqr = delta[0]*delta[0]+delta[1]*delta[1]+delta[2]*delta[2] + SOFTENING;\n        float invDist = 1.0f / sqrtf(distSqr);\n        float invDist3 = invDist * invDist * invDist;\n        force[0] += delta[0] * invDist3;\n        force[1] += delta[1] * invDist3;\n        force[2] += delta[2] * invDist3;\n      }\n      float* vs = p->velocities[effected];\n      vs[0] += dt*force[0];\n      vs[1] += dt*force[1];\n      vs[2] += dt*force[2];\n    }\n    #pragma omp parallel for schedule(guided)\n    for(int effected = 0; effected < N_BODIES; ++effected){\n      float* pos = p->positions[effected];\n      float* vel = p->velocities[effected];\n      pos[0] += vel[0] * dt;\n      pos[1] += vel[1] * dt;\n      pos[2] += vel[2] * dt;\n    }\n  }\n  printf(\"Parallel Execution time: %f seconds with %d threads\\n\\n\", omp_get_wtime()-start_time, NUM_THREADS);\n\n  float res[3];\n  for(int dim = 0; dim < N_DIMS; ++dim){\n    res[dim] = p->positions[0][dim];\n  }\n  free(p);\n\n  const float ref[3] = {102.497765, 107.869682, -2.093829};\n  printf(\"Expecting to hardcoded: %f %f %f\\n\", ref[0], ref[1], ref[2]);\n  printf(\"Got: %f %f %f\\n\", res[0], res[1], res[2]);\n  int success = (fabs(res[0]-ref[0])<0.01f) && (fabs(res[1]-ref[1])<0.01f) && (fabs(res[2]-ref[2])<0.01f);\n  printf(\"Test %s\\n\", (success) ? \"PASSED\" : \"FAILED\");\n}"
        }
    ]
}